{"meta":{"title":"feng的成长日记","subtitle":"","description":"","author":"Mr feng","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"2018-03-18-ssh","date":"2021-06-26T16:54:46.665Z","updated":"2021-06-27T10:30:30.507Z","comments":true,"path":"2021/06/27/2018-03-18-ssh/","link":"","permalink":"http://example.com/2021/06/27/2018-03-18-ssh/","excerpt":"","text":"ssh多个秘钥管理 title: ssh date: 2018/7/13 20:46:25ssh-agent服务管理员模式启动Windows PowerShell1.使用下面两个命令行启动ssh-agent服务1Set-Service -Name ssh-agent -StartupType Manual 1Start-Service ssh-agent 2.添加到代理 1ssh-add ~/.ssh/自定义秘钥名称 3.配置git1git config --global user.email “1044934446@qq.com” 4.生成密钥 1ssh-keygen -t rsa","categories":[],"tags":[]},{"title":"npm script","slug":"2018-04-16-nodejs","date":"2018-04-16T13:13:00.000Z","updated":"2018-04-16T15:25:54.000Z","comments":true,"path":"2018/04/16/2018-04-16-nodejs/","link":"","permalink":"http://example.com/2018/04/16/2018-04-16-nodejs/","excerpt":"npm script的学习","text":"Nodejs – npm scriptnpm脚本: 在 package.json 文件里面 &#123; // ... &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;node build.js&quot; &#125; &#125; script字段是一个对象，它的每个属性对应一个脚本。 当在命令行中运行 npm run build 就会执行脚本 node build.js npm run 之后发生了什么？答：会创建shell,然后在shell里面执行脚本(脚本的执行上下文会指向node_modules/.bin目录) 简写 npm start是npm run start npm stop是npm run stop的简写 npm test是npm run test的简写 npm restart是npm run stop &amp;&amp; npm run restart &amp;&amp; npm run start的简写 获取package.json文件里的属性变量 &#123; &quot;name&quot;: &quot;foo&quot;, &quot;version&quot;: &quot;1.2.5&quot;, &quot;scripts&quot;: &#123; &quot;view&quot;: &quot;node view.js&quot; &#125; &#125; 方法：通过 环境变量process.env，配合前缀npm_package_来获取 比如：获取上面的变量name,可以这样： process.env.npm_package_name 常用脚本命令// 删除目录 &quot;clean&quot;: &quot;rimraf dist/*&quot;, // 本地搭建一个 HTTP 服务 &quot;serve&quot;: &quot;http-server -p 9090 dist/&quot;, // 打开浏览器 &quot;open:dev&quot;: &quot;opener http://localhost:9090&quot;, // 实时刷新 &quot;livereload&quot;: &quot;live-reload --port 9091 dist/&quot;, // 构建 HTML 文件 &quot;build:html&quot;: &quot;jade index.jade &gt; dist/index.html&quot;, // 只要 CSS 文件有变动，就重新执行构建 &quot;watch:css&quot;: &quot;watch &#39;npm run build:css&#39; assets/styles/&quot;, // 只要 HTML 文件有变动，就重新执行构建 &quot;watch:html&quot;: &quot;watch &#39;npm run build:html&#39; assets/html&quot;, // 部署到 Amazon S3 &quot;deploy:prod&quot;: &quot;s3-cli sync ./dist/ s3://example-com/prod-site/&quot;, // 构建 favicon &quot;build:favicon&quot;: &quot;node scripts/favicon.js&quot;, 参考链接： http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html","categories":[{"name":"nodejs","slug":"nodejs","permalink":"http://example.com/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://example.com/tags/nodejs/"}]},{"title":"npm script","slug":"2021-06-22-TestMy","date":"2018-04-16T13:13:00.000Z","updated":"2018-04-16T15:25:54.000Z","comments":true,"path":"2018/04/16/2021-06-22-TestMy/","link":"","permalink":"http://example.com/2018/04/16/2021-06-22-TestMy/","excerpt":"npm script的学习","text":"Nodejs – npm scriptnpm脚本: 在 package.json 文件里面 &#123; // ... &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;node build.js&quot; &#125; &#125; script字段是一个对象，它的每个属性对应一个脚本。 当在命令行中运行 npm run build 就会执行脚本 node build.js npm run 之后发生了什么？答：会创建shell,然后在shell里面执行脚本(脚本的执行上下文会指向node_modules/.bin目录) 简写 npm start是npm run start npm stop是npm run stop的简写 npm test是npm run test的简写 npm restart是npm run stop &amp;&amp; npm run restart &amp;&amp; npm run start的简写 获取package.json文件里的属性变量 &#123; &quot;name&quot;: &quot;foo&quot;, &quot;version&quot;: &quot;1.2.5&quot;, &quot;scripts&quot;: &#123; &quot;view&quot;: &quot;node view.js&quot; &#125; &#125; 方法：通过 环境变量process.env，配合前缀npm_package_来获取 比如：获取上面的变量name,可以这样： process.env.npm_package_name 常用脚本命令// 删除目录 &quot;clean&quot;: &quot;rimraf dist/*&quot;, // 本地搭建一个 HTTP 服务 &quot;serve&quot;: &quot;http-server -p 9090 dist/&quot;, // 打开浏览器 &quot;open:dev&quot;: &quot;opener http://localhost:9090&quot;, // 实时刷新 &quot;livereload&quot;: &quot;live-reload --port 9091 dist/&quot;, // 构建 HTML 文件 &quot;build:html&quot;: &quot;jade index.jade &gt; dist/index.html&quot;, // 只要 CSS 文件有变动，就重新执行构建 &quot;watch:css&quot;: &quot;watch &#39;npm run build:css&#39; assets/styles/&quot;, // 只要 HTML 文件有变动，就重新执行构建 &quot;watch:html&quot;: &quot;watch &#39;npm run build:html&#39; assets/html&quot;, // 部署到 Amazon S3 &quot;deploy:prod&quot;: &quot;s3-cli sync ./dist/ s3://example-com/prod-site/&quot;, // 构建 favicon &quot;build:favicon&quot;: &quot;node scripts/favicon.js&quot;, 参考链接： http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html","categories":[{"name":"nodejs","slug":"nodejs","permalink":"http://example.com/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://example.com/tags/nodejs/"}]},{"title":"Vue api","slug":"2018-03-13-Vue-api","date":"2018-03-13T13:13:00.000Z","updated":"2018-04-16T15:25:54.000Z","comments":true,"path":"2018/03/13/2018-03-13-Vue-api/","link":"","permalink":"http://example.com/2018/03/13/2018-03-13-Vue-api/","excerpt":"Vue部分api解读","text":"Vue api1. 关于mixins与extends。mixins为多继承 extends为单继承，优先级： mixins &lt; extends","categories":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"http协议","slug":"2018-04-15-Protocol","date":"2018-03-13T13:13:00.000Z","updated":"2018-04-16T15:25:54.000Z","comments":true,"path":"2018/03/13/2018-04-15-Protocol/","link":"","permalink":"http://example.com/2018/03/13/2018-04-15-Protocol/","excerpt":"http协议学习","text":"http协议 http是一种无状态协议。 （一脸蒙蔽，什么叫无状态？ 每个请求都是独立的。比如有2个请求，第一次请求之后，第二次请求不知道上一次请求的结果。或者说http没有记忆功能 ） 请求报文请求的方式分为 GET，POST，PUT，DELETE (一般来讲，这4个请求方式对应着 查增改删)关于GET和POST: 同样能够上传数据，get方式把数据放在url里，post把数据放在报文里头。 （现在有个问题：关于GET请求是否能够修改数据？（不安全）） 持久连接： 通过Connection字段的keep-active实现（安全起见，不应该依赖此属性保持连接）(http/1.1支持)&gt;特点：结合报文的Content-Length字段或者空 chunked 块，客户端与服务端能够判断每一次传输是否结束. Transfer-encoding(为chunked时指定 http/2 传输格式)&gt;Transfer-encoding:chunked 下载文件的优缺点 &gt;缺点: 由于无法事先知道文件的chunked数量，所以无法提示用户下载进度。 优点： 可以边生成内容边发送，提高速度。 综上可以得出，在用户体验上，chunked类型传输适合小文件下载，不适合超大文件下载。","categories":[{"name":"protocol","slug":"protocol","permalink":"http://example.com/categories/protocol/"}],"tags":[{"name":"protocol","slug":"protocol","permalink":"http://example.com/tags/protocol/"}]},{"title":"webpack图片优化","slug":"2018-03-13-Webpack","date":"2018-03-13T13:13:00.000Z","updated":"2018-04-16T15:25:54.000Z","comments":true,"path":"2018/03/13/2018-03-13-Webpack/","link":"","permalink":"http://example.com/2018/03/13/2018-03-13-Webpack/","excerpt":"图片优化","text":"webpack1.图片压缩工具（https://github.com/Klathmon/imagemin-webpack-plugin）Imagemin plugin for Webpack This is a simple plugin that uses Imagemin to compress all images in your project. Installnpm install imagemin-webpack-plugin Requires node &gt;=4.0.0 Example Usage123456789101112131415var ImageminPlugin = require(&#x27;imagemin-webpack-plugin&#x27;).default// Or if using ES2015:// import ImageminPlugin from &#x27;imagemin-webpack-plugin&#x27;module.exports = &#123; plugins: [ // Make sure that the plugin is after any plugins that add images new ImageminPlugin(&#123; disable: process.env.NODE_ENV !== &#x27;production&#x27;, // Disable during development pngquant: &#123; quality: &#x27;95-100&#x27; &#125; &#125;) ]&#125; Working with copy-webpack-plugin: 123456789module.exports = &#123; plugins: [ // Copy the images folder and optimize all the images new CopyWebpackPlugin([&#123; from: &#x27;images/&#x27; &#125;]), new ImageminPlugin(&#123; test: /\\.(jpe?g|png|gif|svg)$/i &#125;) ]&#125; APInew ImageminPlugin(options)options.disabletype: Booleandefault: false When set to true it will disable the plugin entirely. This is useful for disabling the plugin during development, and only enabling it during production options.testtype: RegExp or String or Arraydefault: /.*/ This plugin will only run on files that match this test. This is similar to the webpack loader test option (but is not using the same implementation, so there might be major differences!). This can either be a RegExp object, a minimatch glob, a function which gets the filename and returns true if the file should be minified, or an array of any of them. This can allow you to only run the plugin on specific files, or even include the plugin multiple times for different sets of images and apply different imagemin settings to each. This will overwrite everything, including the externalImages option! Example: 123456789101112131415import ImageminPlugin from &#x27;imagemin-webpack-plugin&#x27;module.exports = &#123; plugins: [ // Use the default settings for everything in /images/* new ImageminPlugin(&#123; test: &#x27;images/**&#x27; &#125;), // bump up the optimization level for all the files in my `bigpngs` directory new ImageminPlugin(&#123; test: &#x27;bigpngs/**&#x27;, optipng: &#123; optimizationLevel: 9 &#125; &#125;) ]&#125; Note the order of the plugins matters. CopyWebpackPlugin must be before ImageminWebpackPlugin in the plugins array. options.maxConcurrencytype: Numberdefault: the number of logical CPUS on the system Sets the maximum number of instances of Imagemin that can run at once. Set to Infinity to run a seperate process per image all at the same time. options.optipngtype: Object or nulldefault: &#123; optimizationLevel: 3 &#125; Passes the given object to imagemin-optipng. Set to null to disable optipng. options.gifsicletype: Object or nulldefault: &#123; optimizationLevel: 1 &#125; Passes the given object to imagemin-gifsicle. Set to null to disable gifsicle. options.jpegtrantype: Object or nulldefault: &#123; progressive: false &#125; Passes the given object to imagemin-jpegtran. Set to null to disable jpegtran. options.svgotype: Object or nulldefault: &#123;&#125; Passes the given object to imagemin-svgo. Set to null to disable svgo. options.pngquanttype: Object or nulldefault: null Passes the given object to imagemin-pngquant. Disabled by default. options.pluginstype: Arraydefault: [] Include any additional plugins that you want to work with imagemin here. By default the above are included, but if you want (or need to) you can disable them (by setting them to null) and include them yourself here. A list of possible imagemin plugins can be found here. Example: 123456789101112131415import ImageminPlugin from &#x27;imagemin-webpack-plugin&#x27;import imageminMozjpeg from &#x27;imagemin-mozjpeg&#x27;module.exports = &#123; plugins: [ new ImageminPlugin(&#123; plugins: [ imageminMozjpeg(&#123; quality: 100, progressive: true &#125;) ] &#125;) ]&#125; options.externalImagestype: Objectdefault: &#123; context: &#39;.&#39;, sources: [], destination: null &#125; Include any external images (those not included in webpack’s compilation assets) that you want to be parsed by imagemin.If a destination value is not supplied the files are optimized in place. You can optionally set either of these to a function which will be invoked at the last possible second before optimization to grab files that might not exist at the time of writing the config (see #37 for more info). The paths will work based on the webpack’s (and this plugin’s) context option, so in the following example, the files will be read from ./src/images/**/*.png and will be written to .src/public/images/**/*.png Context only applies to the sources array. Example: 1234567891011121314import ImageminPlugin from &#x27;imagemin-webpack-plugin&#x27;import glob from &#x27;glob&#x27;module.exports = &#123; plugins: [ new ImageminPlugin(&#123; externalImages: &#123; context: &#x27;src&#x27;, // Important! This tells the plugin where to &quot;base&quot; the paths at sources: glob.sync(&#x27;src/images/**/*.png&#x27;), destination: &#x27;src/public/images&#x27; &#125; &#125;) ]&#125; options.minFileSizetype: Integerdefault: 0 Only apply to images that are larger than this value in bytes. options.maxFileSizetype: Integerdefault: Infinity Only apply to images that are smaller than or equal-to this value in bytes. This and minFileSize together can be used to include WebpackImageminPlugin multiple times with multiple configs on different file sizes. Example: 123456789101112131415import ImageminPlugin from &#x27;imagemin-webpack-plugin&#x27;import glob from &#x27;glob&#x27;module.exports = &#123; plugins: [ new ImageminPlugin(&#123; maxFileSize: 10000, // Only apply this one to files equal to or under 10kb jpegtran: &#123; progressive: false &#125; &#125;), new ImageminPlugin(&#123; minFileSize: 10000, // Only apply this one to files over 10kb jpegtran: &#123; progressive: true &#125; &#125;) ]&#125; options.cacheFoldertype: Stringdefault: &#39;&#39; Cache already minified images into a cacheFolder. On next run plugin willcheck for the cached images first. If cached image exists it will simply use that one.Otherwise image will be optimised and written to the cacheFolder for later builds. Note: This is a very simple cache implementation, it WILL NOT intelligently clear thecache if you update the options in this plugin. There also might be significantly more files in the cache than you have images, this is normal, and a side-effect of how I’m deferring to imagemin to determine if a file is an image or not. It can be prevented by setting a good test regex. Example: 12345678910import resolve from &#x27;path&#x27;import ImageminPlugin from &#x27;imagemin-webpack-plugin&#x27;module.exports = &#123; plugins: [ new ImageminPlugin(&#123; cacheFolder: resolve(&#x27;./cache&#x27;), // use existing folder called cache in the current dir &#125;) ]&#125; 以上说明来自官方仓库","categories":[{"name":"webpack","slug":"webpack","permalink":"http://example.com/categories/webpack/"}],"tags":[{"name":"plugin","slug":"plugin","permalink":"http://example.com/tags/plugin/"}]},{"title":"gulp 初探","slug":"2018-03-01-gulp","date":"2018-03-01T15:14:05.000Z","updated":"2018-04-16T15:25:54.000Z","comments":true,"path":"2018/03/01/2018-03-01-gulp/","link":"","permalink":"http://example.com/2018/03/01/2018-03-01-gulp/","excerpt":"gulp构建一个小项目","text":"gulp的最初设计目的是拟合市场。 首先概述下gulp。 gulp是基于nodejs的自动化构建工具。 gulp的流控制很好理解，就是文件的处理分成多个有序步骤。 今天看了下gulp,现在总结一下,并且构建一个能够监听后缀为less的文件， 当文件被修改时能够重新处理代码的项目。 直接进入主题，构建一个简单的项目。准备: 安装nodejs ，npm全局安装gulp （npm install –global gulp);1. 创建package.json文件: npm init;2. 安装依赖 npm install –save-dev gulp-less gulp-sourcemaps gulp-notify gulp-plumber 简单说明下这些依赖的作用: gulp-less(用于处理less文件，转换成css)、gulp-sourcemaps（信息文件，里面储存着位置信息、在代码出错时非常有用）、gulp-notify（代码出错时，能弹窗界面提示）、gulp-plumber（阻止代码出错时，中断gulp.watch）。3.创建文件 gulpfile.js;(入口文件)输入下面代码1234567891011121314151617var gulp = require(&#x27;gulp&#x27;);var less = require(&#x27;gulp-less&#x27;);var sourcemaps = require(&#x27;gulp-sourcemaps&#x27;);var plumber = require(&#x27;gulp-plumber&#x27;);var notify = require(&#x27;gulp-notify&#x27;);gulp.task(&#x27;main&#x27;,function()&#123; gulp.src(&#x27;./*.less&#x27;) .pipe(plumber(&#123;errorHandler: notify.onError(&#x27;Error: &lt;%= error.message %&gt;&#x27;)&#125;)) .pipe(sourcemaps.init()) .pipe(less()) .pipe(sourcemaps.write(&#x27;./source&#x27;)) .pipe(gulp.dest(&#x27;./css/&#x27;))&#125;)gulp.task(&#x27;watchLess&#x27;,function()&#123; gulp.watch(&#x27;./*.less&#x27;,[&#x27;main&#x27;]);&#125;) 5.在当前文件目录下打开命令行，输入 gulp watchLess。","categories":[{"name":"gulp","slug":"gulp","permalink":"http://example.com/categories/gulp/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://example.com/tags/gulp/"}]},{"title":"JavaScript原型","slug":"2017-09-01-Prototype","date":"2017-09-01T15:14:05.000Z","updated":"2018-04-16T15:25:54.000Z","comments":true,"path":"2017/09/01/2017-09-01-Prototype/","link":"","permalink":"http://example.com/2017/09/01/2017-09-01-Prototype/","excerpt":"javascript原型的理解","text":"prototype(原型)原型是函数特有的。 比如 function P()&#123;&#125;, P函数拥有属性(prototype) 原型是可以更改的。 我们可以在原型上添加和修改一些属性和方法，比如 P.prototype = &#123;method1: function()&#123;&#125;&#125; ,但是这种赋值方式是直接覆盖原型，会覆盖之前的原型属性,而我们常常是在原型上添加属性或者方法，所以除非是第一次给原型赋值，否则直接赋值是不正确的。建议用这种方法添加原型: P.prototype.method1 = function()&#123;&#125; 原型链（重要）。(原型上的属性和方法只能通过原型来修改，子实例无法直接修改。) 关于对象属性(通过函数创建的实例)的查找顺序。 首先看一下这个例子: 123P.prototype.prop1 = &#x27;i am prop1 from propotype&#x27;; var p1 = new P; p1.prop1; // i am prop1 from propotype 当通过 p1.prop1 来获取 p1对象的prop1属性时，p1先在自身的属性里面查找prop1，发现没有这个属性，那怎么办呢？p1会到原型链里面去找,他发现确实有这个属性，然后就把原型上prop1的值读取出来。注意：如果没有找到prop1这个属性，他会继续顺着原型链直到找到需要的属性或者到达原型链的顶端(null)为止 123p1.prop1 = &#x27;i am prop1 from my own prop&#x27;p1.prop1 // i am prop1 from my own propP.prototype.prop1 // i am prop1 from propotype 看到没有，当改变实例p1的prop1的值的时候，原型的prop1属性值没有变，这是因为p1本身没有prop1这个属性，直接p1.prop1 = &#39;i am prop1 from my own prop&#39;给他赋值这个属性之后，相当于只是给p1添加prop1属性，并不会改变原型的属性值。当我们再次通过 p1.prop1 来获取值的时候，由于p1自身已经有prop1这个属性了,所以他直接读取自身的属性值，不会去原型上找了。) 原型被子实例共享。 1234567function P()&#123;&#125;; P.prototype.prop1 = new Array; var p1 = new P,p2 = new P; p1.prop1 === p2.prop1; // truep1.__prop__.prop1 = 1; p2.__prop__.prop1; // 1 (p1 跟 p2 都是 P的实例对象, 当修改p1原型的prop1属性值时，p2原型的prop1属性值也被同时修改了，所以他们两个的原型是共享的，。)运算符 instanceof 也是根据原型来判断 某个对象是否属于某个构造函数的.","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]}],"categories":[{"name":"nodejs","slug":"nodejs","permalink":"http://example.com/categories/nodejs/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"},{"name":"protocol","slug":"protocol","permalink":"http://example.com/categories/protocol/"},{"name":"webpack","slug":"webpack","permalink":"http://example.com/categories/webpack/"},{"name":"gulp","slug":"gulp","permalink":"http://example.com/categories/gulp/"},{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://example.com/tags/nodejs/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"protocol","slug":"protocol","permalink":"http://example.com/tags/protocol/"},{"name":"plugin","slug":"plugin","permalink":"http://example.com/tags/plugin/"},{"name":"gulp","slug":"gulp","permalink":"http://example.com/tags/gulp/"},{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]}