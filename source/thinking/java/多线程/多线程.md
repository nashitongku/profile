

##### 1. `ReentrantLock`：a. `lock`与`unlock`;  b.`trylock`   c. `Condition`(使用`await`与`signal`，使用前需要调用`lock`方法获得对象监视器)

（无法像Synchronized一样在异常时自动释放锁，需要手动释放，所以需要在finally里释放锁

）

##### 2. `Synchronized`: 锁住代码块或者方法

##### 	`Synchronized` 缺点：a .不能设置锁超时时间; b.不能通过代码释放锁; c.容易造成死锁 d.无法知道是否成功拿到锁

##### 3. `Volatile`: 适用于只有一个线程进行写的操作，变量被修改后，强制其它线程能够实时读取到主内存变量的最新值。

##### （`volatile` 只能保证可见性，不能保证原子性）



##### 4. ThreadLocal: 每个线程都有变量的副本，互不干扰。



**总结：**

**当只有一个线程写，其它线程都是读的时候，可以用`volatile`修饰变量**

**当多个线程写，那么一般情况下并发不严重的话可以用`Synchronized`，`Synchronized`并不是一开始就是重量级锁，在并发不严重的时候，比如只有一个线程访问的时候，是偏向锁；当多个线程访问，但不是同时访问，这时候锁升级为轻量级锁；当多个线程同时访问，这时候升级为重量级锁。所以在并发不是很严重的情况下，使用Synchronized是可以的。不过Synchronized有局限性，比如不能设置锁超时，不能通过代码释放锁。**

**`ReentranLock` 可以通过代码释放锁，可以设置锁超时。**

**高并发下，Synchronized、ReentranLock 效率低，因为同一时刻只有一个线程能进入同步代码块，如果同时有很多线程访问，那么其它线程就都在等待锁。这个时候可以使用并发包下的数据结构，例如`ConcurrentHashMap`，`LinkBlockingQueue`，以及原子性的数据结构如：`AtomicInteger`。**







