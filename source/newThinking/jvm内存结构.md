https://blog.51cto.com/u_15127556/4121281

线程共享：堆、方法区

线程独有：栈、本地方法栈、程序计数器

堆：存放对象；

方法区：存放类信息

栈：方法运行时，会开辟新的空间存储变量值、指向堆的地址。



堆区的结构：

年轻代、老年代。

年轻代分为：E区、S0、S1区

为什么要这样划分呢？年轻代和老年代的划分是为了更好的内存分派及回收。提高效率

jvm运行参数：

1. -Xms 为jvm启动时分配的内存，比如-Xms200m，表示分配200M
2. -Xmx 为jvm运行过程中分配的最大内存，比如-Xms500m，表示jvm进程最多只能够占用500M内存
3. -Xss 为jvm启动的每个线程分配的内存大小
4. -xmn：年轻代固定大小
5. -xx:newratio：设置年轻代和年老代的比例
6. -XX:MaxTenuringThreshold：设置进入老年代的年龄，默认15岁

（年轻代中存在的对象是死亡非常快的。存在朝生夕死的情况。所以为了提高年轻代的垃圾回收效率，又将年轻代划分为三个区域，一个eden和两个sunrvivor from。在年轻代执行gc的时候，如果老年代的连续空间小于新生代对象的总大小，就会触发一次full gc。是为了给新生代做担保，保证新生代的老年对象可以顺利的进入到老年代的内存区。）

年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会把年龄n以上的对象都放入老年代

如果你要创建一个大于这个大小的对象，比如一个超大的数组，或者是别的啥东西，此时就直接把这个大对象放到老年代里去。压根儿不会经过新生代。

之所以这么做，就是要避免新生代里出现那种大对象，然后屡次躲过GC，还得把他在两个Survivor区域里来回复制多次之后才能进入老年代，那么大的一个对象在内存里来回复制，不是很耗费时间吗？

所以说，这也是一个对象进入老年代的规则。

### 关于gc:

年轻代：



### 老年代

老年代中存放的对象是存活了很久的，年龄大于15的对象。在老年代触发的gc叫major gc也叫full gc。full gc会包含年轻代的gc。但老年代只要执行gc就一定是full gc。
full gc采用的是标记-清除算法。会产生内存碎片。在执行full gc的情况下，会阻塞程序的正常运行。老年代的gc比年轻代的gc效率上慢10倍以上。对效率有很大的影响。

当新对象大于survivor区的50%，可以直接进入老年代



### 永久代(1.8移除)

永久代是hotspot虚拟机，也就是我们使用的java虚拟机的特有的概念，他不属于堆内存，是方法区的一种实现，各大厂商对方法区有各自的实现。永久代存放jvm运行时，需要的类，包含java库的类和方法，在触发full gc的情况下，永久代也会被进行垃圾回收。永久代的内存溢出也就是 pergen space。



回收算法：

标记算法：标记垃圾对象，然后回收。缺点是会造成很多内存碎片。

复制算法：将内存一分为二，标记存活对象，复制到另外一半内存中，将之前的内存清空。缺点是：1G内存只有512M可以使用，内存使用率低。

复制算法优化版：将内存分为E、两个Survivor区，其中Eden区占80%内存空间，每一块Survivor区各占10%内存空间。内存使用率最高能达到90%。